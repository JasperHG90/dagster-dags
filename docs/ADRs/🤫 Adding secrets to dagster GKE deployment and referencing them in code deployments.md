---
creation date: 2024-02-18 10:02
tags:
  - ADR
  - template
  - GKE
  - kubernetes
  - "#secrets"
  - secret-management
  - dagster
template: "[[üè∑ Templates/ADR template]]"
status: ‚úÖ Accepted
homepage:
---
## üìú Table of contents
---
```table-of-contents
```
## ‚úçÔ∏è Context
---
We want to use secrets in code locations so that we can interface with systems outside of GKE. For example, we want to send slack messages when a job fails or succeeds.

We need a structured approach to:
- Adding the secrets to the GKE namespace
- Referencing secrets in a code location
## ü§ù Decision
---
### Secrets added by the Terraform deployment
Some secrets are generated in the 'dagster-infra' Terraform deployment. These secrets are added as 'Opaque' Kubernetes secrets where appropriate. See example [here](https://github.com/JasperHG90/dagster-infra/blob/main/infra/secrets.tf#L22-L35):

```terraform
locals {
  environment_toupper = upper(var.environment)
  credentials = {
    "KUBERNETES_${local.environment_toupper}_SA_JSON_KEY_B64"     = google_service_account_key.kubernetes.private_key
    "CONTAINERADMIN_${local.environment_toupper}_SA_JSON_KEY_B64" = google_service_account_key.containeradmin.private_key
    "DATAREADWRITER_${local.environment_toupper}_HMAC_ACCESS_ID"  = google_storage_hmac_key.key.access_id
    "DATAREADWRITER_${local.environment_toupper}_HMAC_SECRET"     = google_storage_hmac_key.key.secret
  }
  credential_ids = {
    for key, value in local.credentials : key => google_secret_manager_secret.credentials[key].id
  }
  gcp_secret_manager_kubernetes_secret_names = toset([
    for secret in data.google_secret_manager_secrets.secrets.secrets : secret["secret_id"]
  ])
  kubernetes_secrets = merge(
    {
      "GCS_SECRET_ACCESS_KEY" = google_storage_hmac_key.key.secret
      "GCS_ACCESS_KEY_ID"     = google_storage_hmac_key.key.access_id
    },
    {
      for secret in data.google_secret_manager_secrets.secrets.secrets : secret["secret_id"] => data.google_secret_manager_secret_version.secrets[secret["secret_id"]].secret_data
    }
  )
}

resource "google_secret_manager_secret" "credentials" {
  for_each = local.credentials

  secret_id = each.key

  labels = {
    terraform = true
  }

  replication {
    auto {}
  }
}

resource "google_secret_manager_secret_version" "credentials" {
  for_each = local.credentials

  secret      = local.credential_ids[each.key]
  secret_data = each.value
}

resource "kubernetes_secret" "credentials" {
  for_each = local.kubernetes_secrets

  metadata {
    name      = replace(lower(each.key), "_", "-")
    namespace = "dagster-${var.environment}"
  }

  data = {
    "${each.key}" = each.value
  }

  type = "Opaque"
}
```
### Adding secrets not generated by Terraform
To add a secret and make it available to code locations, we have created a [GitHub Actions pipeline](https://github.com/JasperHG90/dagster-infra/blob/main/.github/workflows/add_secrets.yml).

```yaml
# dagster-infra/.github/workflows/add_secrets.yml
name: 'Add secrets'

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  add_secrets:
    name: 'Add secrets'
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v3
    - uses: actions/setup-python@v5
      with:
        python-version: '3.10'
        cache: 'pip'
    - id: 'auth'
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GOOGLE_CREDENTIALS }}'
    - name: 'Set up Cloud SDK'
      uses: 'google-github-actions/setup-gcloud@v2'
    - name: 'Set project'
      run: gcloud config set project jasperg-dagster
    - name: 'Install dependencies'
      run: pip install -r requirements_scripts.txt
    - name: 'Add secrets'
      run: python scripts/add_secret.py from-prefix DAGSTER_SECRET
      env:
        DAGSTER_SECRET_SLACK_BOT_OAUTH_TOKEN: '${{ secrets.DAGSTER_SECRET_SLACK_BOT_OAUTH_TOKEN }}'
```

The GitHub action uses the following python script:

```python
"""
Add a secret from an environment variable to the gcp secrets manager.

Required: gcloud installed and authenticated.
"""

import os
import json
import logging
import tempfile
import pathlib as plb
from dataclasses import dataclass

import typer
import sh

logger = logging.getLogger("add_secret")
handler = logging.StreamHandler()
format = logging.Formatter("%(name)s - %(levelname)s - %(message)s")
handler.setFormatter(format)
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)

app = typer.Typer()


@dataclass
class ProjectConfig:
    region: str
    account: str
    project: str

    def __post_init__(self):
        if self.project is None:
            raise ValueError(
                "Project name not found. Set it using 'gcloud config set project <PROJECT_NAME>'"
            )

    def log(self):
        logger.debug(f"Project: {self.project}")
        logger.debug(f"Account: {self.account}")
        logger.debug(f"Region: {self.region}")


def _get_project_config():
    project_config = json.loads(sh.gcloud.config.list("--format", "json"))
    compute = project_config.get("compute")
    core = project_config.get("core")
    return ProjectConfig(
        region=None if compute is None else compute.get("region"),
        account=None if core is None else core.get("account"),
        project=None if core is None else core.get("project"),
    )


def _get_secret(secret_name: str):
    logger.debug(f"Filtering for secret with name='{secret_name}'.")
    secrets = json.loads(sh.gcloud.secrets.list("--format", "json", "--filter", secret_name))
    logger.debug(f"Found {len(secrets)} secrets.")
    return secrets


def _create_secret(secret_name: str):
    sh.gcloud.secrets.create(secret_name, "--replication-policy", "automatic")
    logger.debug(f"Created secret with name='{secret_name}'.")


def _add_secret_version(secret_name: str, secret_value: str):
    with tempfile.TemporaryDirectory() as tmpdir:
        _secret_file = plb.Path(tmpdir) / "secret.txt"
        with _secret_file.open("w") as f:
            f.write(secret_value)
        sh.gcloud.secrets.versions.add(secret_name, "--data-file", str(_secret_file))
    logger.debug(f"Added secret version to secret with name='{secret_name}'.")


def _from_env_var(env_var_name: str):
    """Add a secret from an environment variable to the gcp secrets manager."""
    logger.debug(f"Looking for environment variable '{env_var_name}'.")
    _value = os.getenv(env_var_name)
    if _value is None:
        raise KeyError(f"Environment variable {env_var_name} not found.")
    _project_config = _get_project_config()
    _project_config.log()
    if len(_get_secret(env_var_name)) == 0:
        _create_secret(env_var_name)
    _add_secret_version(env_var_name, _value)


@app.command()
def from_env_var(
    env_var_name: str = typer.Argument(
        ..., help="Name of the environment variable to add to the secrets manager."
    )
):
    _from_env_var(env_var_name)


@app.command()
def from_prefix(
    prefix: str = typer.Argument(
        ..., help="Prefix of the environment variables to add to the secrets manager."
    )
):
    for k in os.environ.keys():
        if k.startswith(prefix):
            _from_env_var(k)


if __name__ == "__main__":
    app()
```

A user can add secrets to the GKE deployment by adding them to the 'dagster-infra' [Secrets and variables](https://github.com/JasperHG90/dagster-infra/settings/secrets/actions) GitHub settings.

Secrets must be prefixed with "DAGSTER_SECRET", and will be added to the GKE 'dagster-prd' namespace as an 'Opaque' secret. The name of the kubernetes secret will be in lower-case, and underscores are replaced with hyphens.

For example:
`DAGSTER_SECRET_SLACK_BOT_OAUTH_TOKEN` --> `dagster-secret-slack-bot-oauth-token`

Note that, when the secret is used in a python Dagster DAG definition, it should still be referred to using the name as defined in the GitHub secret settings. (see below for example).
### Using secrets in code locations
To use secrets in a code location in the 'dagster-dags' repository, a user must reference them in the helm 'values.yaml' file under "envSecrets". (see example [here](https://github.com/JasperHG90/dagster-infra/settings/secrets/actions)).

```yaml
# values.yaml (dagster-dags helm deployment values)
deployments:
	...
    envSecrets:
      - name: gcs-access-key-id
      - name: gcs-secret-access-key
      - name: dagster-secret-slack-bot-oauth-token
```

The secrets can be referenced in a DAG using the "os" library:

```python
import os
os.environ["DAGSTER_SECRET_SLACK_BOT_OAUTH_TOKEN"]
```
## ‚òùÔ∏èConsequences
---
- Users should not add secrets manually, but should add them using the GitHub Actions pipeline.
- Users don't have to add secrets manually. They can simply refer to the secrets they want and use the secrets in their own pipelines.
